# -*- coding:utf-8 -*-
'''
Floyd算法用于给出一个图中所有顶点到所有顶点之间最短距离（以及最短距离的走法）的算法
* 相对，Dijkstra是求出一个固定顶点到所有顶点之间的最短距离
使用Floyd算法的一个大前提是图用邻接矩阵表示。
Floyd的想法是这样的，对于任意两点vi和vj之间的路径，可以给其一个限制，如途径的所有路径点的下标都不超过k，0<=k<vnum
当k从0升到vnum的过程中，一直取历史记录中路径的最短值    （开始阶段可能不存在，比如vi到vj之间经过路径点下标最大是0，那么也就是说vi和vj之间要不直连，要不经过v0，要不就不存在了。针对不存在的边做特殊处理)
当k达到vnum - 1的时候，所保持着的路径最短值就是要找的最短路径了。
在k+=1之前，我们保证将图中所有的(vi,vj)点对的相关信息都求出来，再去进行k+1情况的讨论。

那么怎么样才能“取最短值”呢？
首先我们假设某路径不存在时取的路径值是无穷大
在限制路径途径节点下标都不超过k的时候，vi到vj可能有vi,vx,vy... vj这样一条路径，其中所有的x,y...都小于等于k。
此时k的情况已经都计算完成。也就是说图中任意两点间，途径节点下标小于等于k的最短路径都已经得到了。
此时k += 1，这样vi到vj这条路径就被放宽了一点，可以尝试能不能经过v(k+1)去找一条更短的路径。
如果找到某条经过v(k+1)的路径（一定要经过，否则不经过v(k+1)的路径的最小值就是当前值）没有现在的vx,vy...短，那就保留原值。反之，更新为新值。
那么又要怎么看经过v(k+1)的最短路径是哪个？其实可以想到，vi到vj，经过v(k+1)的最短路径，就是vi到v(k+1)以及v(k+1)到vj两者之和。
同时，这两者中间路过的节点下标都小于k+1（或者说小于等于k），所以这两者的长度早在对k的讨论时就已经有了，直接拿来现成用就行了。
用数学语言描述就是a[i][j] = min{a[i][j],a[i][k]+a[k][j]}，其中矩阵a保存的a[i][j]就是指当前我们找到的vi到vj最短路径的长度。

具体实现是还有一些细节问题需要考虑，比如是不是对每一个k都要新建一个矩阵（不是，书上我有用坐标轴解释的图解笔记）
矩阵只是记录了最短路径的长度，对于最短路径的具体走法要怎么记录等等。

关键词： 整个邻接矩阵的完全化处理，之后再做下一次遍历；对可以经过的节点逐渐放宽限制；保存具体路径走法另需一个矩阵

思考一大堆但是程序很简单，时间复杂度是O(V^3)，空间复杂度是O(V^2)
'''

def floyd(graph):
    '''
    graph参数是一个邻接矩阵实现的图
    :param graph:
    '''
    vnum = graph.vertex_num()
    a = [[float('inf') if graph[i][j] == 0 else graph[i][j] for j in range(vnum)] for i in range(vnum)]    # 工作区域矩阵，用来记录和更新两点间最短距离的值
    N = [[-1 if a[i][j] == float('inf') else j for j in range(vnum)] for i in range(vnum)]
    # N矩阵用来记录vi到vj最短路径上，vi的下一步走到的节点下标是多少。比如说是vx，那么如果再走一步，因为vx到vj的最短路径是vi到vj路径的一个子集
    # 所以直接再找出N[x][j]，以此类推最终可以找到N[j][j]，这过程中所有下标组成的就是一条vi到vj的最短路径了。

    for k in range(vnum):
        for i in range(vnum):
            for j in range(vnum):
                if a[i][j] > a[i][k] + a[k][j]:
                    a[i][j] = a[i][k] + a[k][j]
                    N[i][j] = N[i][k]  # 最短路径改成经过vk了，所以vi到vj路径上的下一节点应该更新成vi到vk上的下一节点
# -*- coding:utf-8 -*-

class Record:
    def __init__(self,key,value):
        self.key = key
        self.value = value

    def __repr__(self):
        return '{0}: {1}'.format(str(self.key),str(self.value))

'''
快速排序
快速排序采用的是递归的思想，而递归部分需要的参数是总序列的一部分。如果每次递归都创建一个新的子序列来处理的话
会导致耗费太多的内存空间，因此参数的选择上可以设置为总序列和一个start一个end，两个上下限来指出子序列
为了统一接口，让主排序函数的参数只有一个主序列，可以将递归函数放在主函数内部定义
'''

def quick_sort(lst):
    def partition(lst,start,end):
        if start >= end:
            return
        pivot = lst[start].key
        i = j = start + 1
        while j <= end:
            if lst[j].key < pivot:
                lst[j],lst[i] = lst[i],lst[j]
                i += 1
            j += 1
        i -= 1
        lst[start],lst[i] = lst[i],lst[start]

        partition(lst,start,i-1)
        partition(lst,i+1,end)

    partition(lst,0,len(lst)-1)
'''
############################################
快速排序分析
快排的思想是选定序列中的一个值作为基准pivot，然后将剩余元素中所有小于pivot的都安排到序列靠左，大于的都安排到右。这里存在两个问题
1. 基准pivot如何选择
2. 剩余元素如何遍历
一般的快排的实现，pivot都是选择序列的第一个元素，至于第二个问题，不同实现不一样，可以参考博文，就不重复写了。

按照上述标准做完遍历后，序列处于的状态应该是[基准,小,小...小,大,大...大]。可见我们还需要将基准和最后一个比基准小的值互换位置。
接下来就是递归地对基准左边和右边序列分别进行递归的快速排序。
复杂度：
对于快排以及其他一些复杂点的排序算法，其最好、最坏情况不能简单的用已有序和逆序两种情况来判断。
比如对于快排，其最好情况应该描述为，每次选定的基准都是当前序列中接近中位数的值，此时序列被划分为长度大概相等的两段。这种情况下，
总共划分次数大约是O(logn)的，而每次划分之后交换元素最多也就当前划分出的子序列的长度，也就是说同样长度的所有子序列，交换总次数不超过n
总的来看，一个序列最好情况下复杂度是O(nlogn)
最坏的情况是，每次选择的基准都是端值，这是划分出的子序列必然有一个空序列，并且要划分n-1次。
对于另一个非空的序列，就要各做n-1次比较。即使不做交换，这个算法复杂度都会达到O(n^2)
平均情况，抽象看，快速排序的过程其实像是以基准值为根节点，构建一个二叉排序树。由于构建二叉排序树的过程是O(nlogn)的（每个节点插入都是logn，然后共n个节点）
所以平均情况的快速排序可以达到O(nlogn)，比之前朴素的几种算法都要快。因此称快速排序
稳定性：
在上面的实现中，虽然lst[j].key < pivot，当存在和pivot相等的那些值时不主动去移动这些值引起不稳定。但是在处理和pivot不等的其他相同排序码的对象时就不一定了。
比如原序列中有ABC序列的三个key都小于pivot的值，由于实现中j是从后往前排列的，所以最后pivot左边序列中会变成CBA的顺序。其他快排实现大多也都存在类似问题，因此快排不稳定。
适应性：
根据上述分析，快排并不因为原序列接近有序而变快（事实上更慢了，是最慢的情况…），因此不具有适应性。
优化：
快排低效的原因是pivot没有选靠近中间值的值，导致分段不均匀。因此可以在选择pivot的时候多取几个值看哪个比较合适。一种常见的办法是取头，尾和中三个值，取三者中间值作为pivot
############################################
'''

def merge_sort(lst):
    '''
    在我潜意识中的归并算法，merge总是要return出一个列表，这就意味着需要O(n^2)的辅助空间。而且最终返回的排序结果不是原对象
    造成了not-in-place的排序。书里的这种算法对空间复杂度做出了一定优化
    :param lst:
    :return:
    '''
    slen, llen = 1, len(lst)    # slen是需要合并的子序列的长度，初始时的子序列长度是1，llen是总长度
    templst = [None] * llen    # templst是辅助空间，用于保存一些中间计算结果。这是优化后的情况，相当于空间复杂度降到了O(n)

    def merge_pass(lfrom,lto,llen,slen):
        '''
        对固定长度的所有待合并子序列依次合并，而单对的子序列的合并具体操作由merge函数定义
        :param lfrom:  源序列
        :param lto:   辅助空间
        :param llen:  序列总长
        :param slen:  本次处理的子序列长
        :return:
        '''
        def merge(lfrom, lto, low, mid, high):
            '''
            进行合并操作的函数。和之前自己想的归并排序的这个函数差别不大，还是三个循环
            不过应该注意的是它也为了适配O(n)的辅助空间进行了改造
            low,mid和high分别是外部传入的lfrom中待合并的两段子序列的 左子序列起始下标；右子序列开始下标；右子序列结束下标
            '''
            i,j,k = low,mid,low
            # 将lfrom中的[low:mid]和[mid:high]两段子序列合并成lto[low:high]序列
            while i < mid and j < high:
                if lfrom[i].key <= lfrom[j].key:
                    lto[k] = lfrom[i]
                    i += 1
                else:
                    lto[k] = lfrom[j]
                    j += 1
                k += 1
            while i < mid:
                lto[k] = lfrom[i]
                i += 1
                k += 1
            while j < high:
                lto[k] = lfrom[j]
                j += 1
                k += 1

        i = 0
        while i + 2 * slen < llen:    # 通过游标i不断向后移动两个子序列长度，依次每次取出两个子序列
            merge(lfrom, lto, i, i+slen, i+2*slen)    # 合并两个子序列并将合并后的结果保存到辅助空间中。
            i += 2 * slen
        # 至此，如果总序列刚好可以分成若干对的子序列对，就结束了。麻烦就麻烦在有可能有多余的存在。有多余的时候还得分成两种情况考虑
        if i + slen < llen:
            # 对于剩余的元素多余一个子序列长度，但是又凑不齐一对两个子序列的情况，直接调用merge合并即可
            # merge中对于不对称的合并有相关的合并处理
            merge(lfrom, lto, i, i+slen, llen)
        else:
            # 如果连一个子序列都凑不齐，那么就谈不上什么合并了，直接将这个子序列加入到辅助空间中
            for j in range(i,llen):
                lto[j] = lfrom[j]
        # 至此，子序列长度为slen时，归并完成后的序列的情况就被存入了lto序列中。

    while slen < llen:
        merge_pass(lst,templst,llen,slen)
        slen *= 2    # 子序列长度两倍两倍增长的归并称为二路归并，将此参数变化也可以做三路、四路归并等等。
        # 做到这里的时候，其实templst中的序列才是（部分）完成排序的序列
        # 当时直接将其复制回lst的话templst就得重新申请一个新的，总之都会需要更多的辅助空间
        # 所以解决办法是，趁着循环还未跳出，将templst和lst互换参数位置，再调用一次merge_pass。
        # 因为templst和lst中必然有一个正确排序，在循环跳出前再反着调用一次merge_pass可以保证lst是正确排序的序列
        merge_pass(templst,lst,llen,slen)
        slen *= 2    # slen这个*=2可加可不加，加上了促进提升效率

'''
##################################################
归并排序分析
复杂度：
如果不计赋值的复杂度，主要的复杂度都集中在merge函数中。对于每个长度为k的子序列，归并时进行比较的次数最多是2k，最少是k，
因此固定一个子序列长度进行一次归并的总复杂度是O(n)的。另一方面，由于分割子序列的过程和构造树类似，也是O(logn)，所以总的归并排序的时间复杂度还是O(nlogn)
归并时进行比较的次数最多、最少其实就代表了对于归并排序最坏和最好的情况。可以看到不论是最好还是最坏，总的算法复杂度都是O(nlogn)。
其实归并排序最多被研究的还是其空间复杂度相关。这个算法里面采用的是O(n)的辅助空间。有些其他研究可以继续优化这个空间复杂度。不再展开。
稳定性：
要在归并排序中保持稳定性，只需要在合并的时候保证同值元素左序列入队。换句话说，判断条件lfrom[i] <= lfrom[j]这个等号不能去掉
适应性:
没有适应性
##################################################
'''

def shell_sort(lst):
    '''
    希尔排序的特征是三个循环，第一个控制gap，gap就是每次计算的间隔，没什么好说的
    第二个控制i，i是从gap到序列尾的遍历，相当于是选择一个有间隔的子序列
    第三个控制j，j就是有间隔子序列中进行冒泡排序的控制变量，每一轮j的循环都保证这个有间隔子序列最小值已经在最左边
    :param lst:
    :return:
    '''
    gap = len(lst) // 2
    while gap > 0:
        i = gap
        while i < len(lst):
            j = i
            while j >= gap:    # 开始进来的时候i = gap，所以j必须>=gap
                if lst[j] < lst[j-gap]:
                    lst[j],lst[j-gap] = lst[j-gap],lst[j]
                j -= gap
            i += 1
        gap /= 2
'''
##################################
希尔排序分析
复杂度：
笼统来看，算法刚开始时，整个序列处于比较无序的状态时，步长很大，因此需要交换的元素数量比较少
随着步长减小，每一趟需要交换的元素可能变多，但是此时序列又开始逐渐变得有序。这样一均衡，使得整体的时间复杂度可接受了
从最坏的角度来看，另lst长度为n，开始gap = n/2的时候，序列被分成n/2组，每组都交换一次，总的时间是1 * n/2
gap /= 2，此时gap = n/4，序列被分成n/4组，由于每组有四个元素了，所以要交换(1+2+3)次（最坏情况，此时每组都处于逆序状态），总得时间(1+2+3)*n/4
...
由此可以得出递推公式，然后把这些项先化简，得到第m次步长减小后，总交换次数为(2^m - 1) * n/2^m
将这些项累加起来就是最坏情况下希尔排序的总复杂度，是(1+3+7+...+2^m-1) * n/2^m = n*(n-(1/2 + 1/4 + 1/8 + ...)) = n^2 * (1-(1/2)^m)
可得，总复杂度总是小于n^2的，但是随着n的加大，m随之加大，这个值越来越接近n^2。

稳定性：
很明显不稳定，因为同值元素可能再不同的有间隔子序列中处理，有可能在一个这样的子序列中，这个值是最大，会被移到右边，在另一个中最小，被移到左边
因此稳定性就不存在了。
适应性：
理论证明，希尔排序最低的复杂度可以达到O(n^1.5)，这主要是依靠gap的变化策略。实际上一般情况下希尔排序的表现是O(nlogn)的


##################################
'''

def heap_sort(lst):
    '''
    堆排序，主要步骤是两步。第一，构建堆，通过对所有非叶节点逆序进行一次heapify（向下筛选）操作
    第二，排序，不断地拿出堆顶，互换堆顶堆尾位置后对堆顶做一次heapify操作
    heapify老是写错… 记住：heapify本身就是一个循环体
    接受两个参数，j和e，分别指代向下筛选的开始和结束下标
    大循环条件是左or右子节点<e，循环体中是两个if/else组成。第一个用于确认可能的交换对象，第二个用于交换或直接跳出循环
    排序部分也别忘了指定动态的heapify范围，别让乡下筛选操作把已经排好序的打乱了。
    '''
    llen = len(lst)
    last_i = llen - 1
    def heapify(j,e):
        while 2*j+1 < e or 2*j+2 < e:
            if 2*j+2 < e and lst[2*j+2] < lst[2*j+1]:
                c = 2*j+2
            else:
                c = 2*j+1
            if lst[j] > lst[c]:
                lst[j],lst[c] = lst[c],lst[j]
                j = c
            else:
                break

    for j in range((last_i-1)//2, -1, -1):
        heapify(j,llen)

    i = last_i
    while i >= 0:
        lst[i],lst[0] = lst[0],lst[i]
        heapify(0,i)
        i -= 1

'''
############################################
堆排序分析
复杂度
在二叉树中就已经说明过，构建堆的操作是O(n)的（高度为h的树共h/2^h棵，向下筛选最多交换h-1次，求sum即可）
而一般来说，后续排序操作是O(nlogn)，因此堆排序总体的复杂度是O(nlogn)的。
但是也应该注意到，由于采用了交换堆顶和堆尾的实现，致使堆顶无论如何都要去做向下筛选，因此这个O(nlogn)是无法避免的
空间复杂度自然是O(1)
稳定性
由于将一维结构转化为二维的堆结构之后，可以进行跳过好几个元素进行交换处理，会导致原线性序列的混乱，因此不具有稳定性
适应性
如上复杂度中所述，即使是已经有序的序列，建堆操作可以直接跳过，后续排序时还是不可避免向下筛选过程。因此不具有适应性
############################################
'''



'''
桶排序是一类排序的总称。最简单的桶排序描述如下：
当排序关键码的集合比较小，可选的关键码比较少时，可以将所有元素，根据其关键码的值都放到统一的几个桶中
桶可以采取链表之类的实现。
因为桶的标识值的大小是知道的，所以我们可以按照要求顺序考察各个桶，将其中的元素取出来依次排好，这就完成了排序
对于稳定性，只要我们维持出入桶顺序的有序性，并且是队列有序性，则可以保证。
'''

def radix_sort(lst, d, r):
    '''
    基数排序，常用于多元素关键码的排序
    本实现基于LSD排序
    '''
    rlists = [[] for i in range(r)]
    llen = len(lst)
    for m in range(-1, -d-1, -1):
        for j in range(llen):
            rlists[lst[j].key[m]].append(lst[j])
        j = 0
        for i in range(r):
            tmp = rlists[i]
            for radix in tmp:
                lst[j] = radix
                j += 1
            while len(rlists[i]) > 0:
                del rlists[i][0]

'''
######################################
蒂姆排序
蒂姆排序是Python官方用于实现Python中各种sort以及sort相关函数的算法。
这个算法是基于归并排序，并且吸收了插入排序一些特点的算法，具有稳定性和适应性。
从复杂度方面来看，时间复杂度大多情况是O(nlogn)，对于一些很理想的情况，可以降低到O(n)
空间复杂度会使用到O(n/2)，也有一些情况可以不用那么多空间。
######################################
'''

if __name__ == '__main__':
    import random
    lst = []
    for i in range(10):
        lst.append(Record(i,i))
    random.shuffle(lst)
    print lst
    heap_sort(lst)
    print lst
# -*- coding:utf-8 -*-

'''
排序过程中主要有两个操作，一个是对比关键码，另一个是交换/移动元素。把这两个操作视为构成时间复杂度的元操作。
排序算法有两个特性，一是稳定性，即同关键码元素排序完毕后是否保持和原序列中同样的相对位置。
二是适应性，即算法如果处理接近有序的序列的复杂度比较小的话，称其具有适应性

下面这几个算法是几个比较朴素的排序算法，它们的共同特点是很自然但是最坏情况的复杂度较高
'''
class Record:
    def __init__(self,key,value):
        self.key = key
        self.value = value
    def __repr__(self):
        return str(self.value)

def insert_sort(lst):
    '''
    插入排序，从前到后遍历序列，某个元素之前所有元素都排序完毕，当前元素只要插入到前面已排序部分中合适位置，并将这个位置之后的所有元素后移一格即可
    :param lst:
    :return:
    '''
    for i in range(1,len(lst)):
        x = lst[i]
        j = i
        while j > 0 and lst[j-1].key > x.key:
            lst[j] = lst[j-1]
            j -= 1
        lst[j] = x

'''
######################################################
插入排序分析
复杂度：
外层循环总共要走n-1次，而内存循环执行次数看具体情况，
如果序列本身就已经排序完毕，那么内层循环一次也不执行，此时复杂度是O(n)
如果序列本身是原序列的逆序列，那么内层循环总共要执行1+2+3...+(n-1)次，即n*(n-1)/2次，此时复杂度是O(n^2)
下面考虑一般情况，假设元素分到序列中每个位置概率相同，那么内循环要比较的次数将会是总内循环次数的一半，即总次数n*(n-1)/4，复杂度仍然是O(n^2)
稳定性：
因为在具体算法中，lst[j-1].key > x.key，而不是>=，因此一旦碰到某个和x的key相等的元素，此时直接插入x
又由于遍历序列是从前到后的，所以原本在后面的x排序之后仍然处于同key序列的后面，因此是稳定的排序
适应性：
根据上面对有序、逆序情况分析可知，其具有适应性
######################################################
'''

def bubble_sort(lst):
    '''
    冒泡排序，和插入排序很类似，这个实现中是从前往后冒泡，因此外循环保证数组倒数若干位是有序的。
    如果改一下方向，使之从后往前冒泡，此时就和插入排序很像了。一直保证数组的前若干位都有序，
    而每一趟内循环的目标，是把当前未排序部分中的最小值放到最左边，列入已排序部分
    :param lst:
    :return:
    '''
    for j in range(len(lst)-1,0,-1):
        for i in range(j):
            if lst[i].key > lst[i+1].key:
                lst[i],lst[i+1] = lst[i+1],lst[i]

'''
###############################################
冒泡排序分析
复杂度：
外层循环走n-1次，内层循环则也是看情况。
假如原序列已经有序，内层循环一次操作也不用做,复杂度O(n)
假如原序列逆序，内层循环要做(n-1)+...+2+1次操作，总体复杂度是O(n^2)
一般情况，和插入排序分析一样，将其看做均匀分布的话，内层操作的次数可以减半，但是总复杂度依然是O(n^2)
稳定性：
同样，由于lst[i].key 不是>= lst[i+1].key，因此是稳定的
适应性：
有适应性咯
优化：
最好情况下复杂度分析中有一点不是很严谨。那就是如果最好情况，虽然内存循环没有做一次交换操作过，但是外层循环还是傻乎乎地走了n-1次
那么就可以在进入内层循环前维护一个“是否进行交换”的变量，如果这个变量在内层循环中始终没有被改变，那么就意味着当前j之前所有元素已经有序（因此无需进行任何一次交换）
在有这个变量的情况下，最好情况时，整个排序外层循环只走一次，内层循环进行了n-1次比较，总的复杂度是O(n)。
优化后的函数见下
###############################################
'''

def bubble_sort_1(lst):
    for j in range(len(lst)-1,0,-1):
        found = False
        for i in range(j):
            if lst[i] > lst[i+1]:
                lst[i],lst[i+1] = lst[i+1],lst[i]
                found = True
        if found is False:    # 没有进行过哪怕一次交换，已经有序，可以直接break
            break

def select_sort(lst):
    '''
    选择排序感觉是最接近一般思维的排序算法。
    和上面的简单排序类似，其保证了数组中的一部分始终处于有序状态而对剩余无序状态进行处理
    和插入排序或者冒泡排序选择的“插入”“冒泡”策略不同，选择排序直接了当地试图去找到未排序序列中的最小值
    :param lst:
    :return:
    '''
    for i in range(len(lst)):
        k = i    # 维护k为剩余未排序序列中最小值的下标
        for j in range(1,len(lst)):
            if lst[j] < lst[k]:
                k = j
        if i != k:    # 交换未排序序列第一位和最小值位置的数，使得排序序列长度变长一点，未排序序列缩短一点
            lst[i],lst[k] = lst[k],lst[i]

'''
############
上面这种实现被称为直接选择排序。
复杂度：
外层循环老样子n-1次
内层循环则有点不同了。无论序列是否有序，j这个下标还是要去遍历未排序序列的所有元素，以确定最小值
因此，无论序列情况如何，这个算法的复杂度都是O(n^2)
稳定性：
由于选择为排序序列中的最小值，取的是序列中最后一次出现的最小值的下标，然后将其换到了为排序序列的最前面，
易得算法没有稳定性
适应性：
算法也没有适应性
优化：
可以看出，直接选择排序可以说是不是很理想。可以感觉到，这种不理想主要是因为对未排序序列中最小值的选择采用的是最朴素的遍历记录最小值的办法
如果可以将这部分优化一下，可以得到更好一点的算法。
具体来说，堆排序其实可以看做是一种优化后的选择排序。因为其选择为排序序列中最小值的办法不是线性的遍历全部，而是去保证一个堆的堆序，
从而在lgn的时间中就获取到了最小值。
堆排序的具体代码不在这个文件里写。
############
'''

def period(lst,func):
    lst = list(lst)
    start = time.time()
    func(lst)
    end = time.time()
    return end - start


if __name__ == '__main__':
    import time,random
    lst = []
    for i in range(1000):
        lst.append(Record(i,i))
    random.shuffle(lst)
    for func in (bubble_sort_1,insert_sort,select_sort):
        print period(lst,func)

    # 做个简单的效率比较，其中insert_sort最快，bubble_sort其次，select_sort最慢一些。

'''
更多的高级一点的排序算法在另一个文件中写
'''